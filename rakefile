require 'rake/clean'
require 'tempfile'

# Build Constants
REPO_ROOT = File.dirname(__FILE__)
BUILD_DIR = File.join(REPO_ROOT, "build")
REPORT_DIR = File.join(REPO_ROOT, "reports")
LMS_REPORT_DIR = File.join(REPORT_DIR, "lms")

# Packaging constants
DEPLOY_DIR = "/opt/wwc"
PACKAGE_NAME = "mitx"
LINK_PATH = "/opt/wwc/mitx"
PKG_VERSION = "0.1"
COMMIT = (ENV["GIT_COMMIT"] || `git rev-parse HEAD`).chomp()[0, 10]
BRANCH = (ENV["GIT_BRANCH"] || `git symbolic-ref -q HEAD`).chomp().gsub('refs/heads/', '').gsub('origin/', '')
BUILD_NUMBER = (ENV["BUILD_NUMBER"] || "dev").chomp()

if BRANCH == "master"
    DEPLOY_NAME = "#{PACKAGE_NAME}-#{BUILD_NUMBER}-#{COMMIT}"
else
    DEPLOY_NAME = "#{PACKAGE_NAME}-#{BRANCH}-#{BUILD_NUMBER}-#{COMMIT}"
end
PACKAGE_REPO = "packages@gp.mitx.mit.edu:/opt/pkgrepo.incoming"

NORMALIZED_DEPLOY_NAME = DEPLOY_NAME.downcase().gsub(/[_\/]/, '-')
INSTALL_DIR_PATH = File.join(DEPLOY_DIR, NORMALIZED_DEPLOY_NAME)

# Set up the clean and clobber tasks
CLOBBER.include(BUILD_DIR, REPORT_DIR, 'cover*', '.coverage')
CLEAN.include("#{BUILD_DIR}/*.deb", "#{BUILD_DIR}/util")

def select_executable(*cmds)
    cmds.find_all{ |cmd| system("which #{cmd} > /dev/null 2>&1") }[0] || fail("No executables found from #{cmds.join(', ')}")
end

def django_admin(system, env, command, *args)
    django_admin = ENV['DJANGO_ADMIN_PATH'] || select_executable('django-admin.py', 'django-admin')
    return "#{django_admin} #{command} --settings=#{system}.envs.#{env} --pythonpath=. #{args.join(' ')}"
end

task :default => [:pep8, :pylint, :test]

directory REPORT_DIR
directory LMS_REPORT_DIR

desc "Run pep8 on all libraries"
task :pep8 => REPORT_DIR do
    sh("pep8 --ignore=E501 lms/djangoapps common/lib/* | tee #{REPORT_DIR}/pep8.report")
end

desc "Run pylint on all libraries"
task :pylint => REPORT_DIR do
    Dir["lms/djangoapps/*", "common/lib/*"].each do |app|
        ENV['PYTHONPATH'] = File.dirname(app)
        app = File.basename(app)
        sh("pylint --rcfile=.pylintrc -f parseable #{app} | tee #{REPORT_DIR}/#{app}.pylint.report")
    end
end

[:lms, :cms].each do |system|
    task_name = "test_#{system}"
    report_dir = File.join(REPORT_DIR, task_name)
    directory report_dir

    desc "Run all django tests on our djangoapps for the #{system}"
    task task_name => report_dir do
        ENV['NOSE_XUNIT_FILE'] = File.join(report_dir, "nosetests.xml")
        ENV['NOSE_COVER_HTML_DIR'] = File.join(report_dir, "cover")
        sh(django_admin(system, :test, 'test', *Dir["#{system}/djangoapps/*"].each))
    end
    task :test => task_name

    desc <<-desc
        Start the #{system} locally with the specified environment (defaults to dev).
        Other useful environments are devplus (for dev testing with a real local database)
        desc
    task system, [:env, :options] => [] do |t, args|
        args.with_defaults(:env => 'dev', :options => '')
        sh(django_admin(system, args.env, 'runserver', args.options))
    end
end

Dir["common/lib/*"].each do |lib|
    task_name = "test_#{lib}"

    report_dir = File.join(REPORT_DIR, task_name.gsub('/', '_'))
    directory report_dir

    desc "Run tests for common lib #{lib}"
    task task_name => report_dir do
        ENV['NOSE_XUNIT_FILE'] = File.join(report_dir, "nosetests.xml")
        sh("nosetests #{lib} --cover-erase --with-xunit --with-xcoverage --cover-html --cover-inclusive --cover-package #{File.basename(lib)} --cover-html-dir #{File.join(report_dir, "cover")}")
    end
    task :test => task_name
end

task :runserver => :lms

desc "Run django-admin <action> against the specified system and environment"
task "django-admin", [:action, :system, :env, :options] do |t, args|
    args.with_defaults(:env => 'dev', :system => 'lms', :options => '')
    sh(django_admin(args.system, args.env, args.action, args.options))
end

task :package do
    FileUtils.mkdir_p(BUILD_DIR)
    
    Dir.chdir(BUILD_DIR) do

        postinstall = Tempfile.new('postinstall')
        postinstall.write <<-POSTINSTALL.gsub(/^\s*/, '')
        #! /bin/sh
        set -e
        set -x

        chown -R makeitso:makeitso #{INSTALL_DIR_PATH}
        chmod +x #{INSTALL_DIR_PATH}/collect_static_resources

        service gunicorn stop || echo "Unable to stop gunicorn. Continuing"
        rm -f #{LINK_PATH}
        ln -s #{INSTALL_DIR_PATH} #{LINK_PATH}
        chown makeitso:makeitso #{LINK_PATH}

        /opt/wwc/mitx/collect_static_resources

        # Delete mako temp files
        rm -rf /tmp/tmp*mako

        service gunicorn start
        POSTINSTALL
        postinstall.close()
        FileUtils.chmod(0755, postinstall.path)

        args = ["fakeroot", "fpm", "-s", "dir", "-t", "deb",
            "--verbose",
            "--after-install=#{postinstall.path}",
            "--prefix=#{INSTALL_DIR_PATH}",
            "--exclude=**/build/**",
            "--exclude=**/rakefile",
            "--exclude=**/.git/**",
            "--exclude=**/*.pyc",
            "--exclude=**/reports/**",
            "-C", "#{REPO_ROOT}",
            "--provides=#{PACKAGE_NAME}",
            "--name=#{NORMALIZED_DEPLOY_NAME}",
            "--version=#{PKG_VERSION}",
            "-a", "all",
            "."]
        system(*args) || raise("fpm failed to build the .deb")
    end
end

task :publish => :package do
    sh("scp #{BUILD_DIR}/#{NORMALIZED_DEPLOY_NAME}_#{PKG_VERSION}*.deb #{PACKAGE_REPO}")
end
